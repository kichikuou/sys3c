/* Copyright (C) 2020 <KichikuouChrome@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
*/
#include "common.h"
#include "s2utbl.h"
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <uchar.h>

static const uint8_t hankaku81[] = {
	0x20, 0xa4, 0xa1, 0x00, 0x00, 0xa5, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xa2, 0xa3, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const uint8_t hankaku82[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa7,
	0xb1, 0xa8, 0xb2, 0xa9, 0xb3, 0xaa, 0xb4, 0xab,
	0xb5, 0xb6, 0x00, 0xb7, 0x00, 0xb8, 0x00, 0xb9,
	0x00, 0xba, 0x00, 0xbb, 0x00, 0xbc, 0x00, 0xbd,
	0x00, 0xbe, 0x00, 0xbf, 0x00, 0xc0, 0x00, 0xc1,
	0x00, 0xaf, 0xc2, 0x00, 0xc3, 0x00, 0xc4, 0x00,
	0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0x00, 0x00,
	0xcb, 0x00, 0x00, 0xcc, 0x00, 0x00, 0xcd, 0x00,
	0x00, 0xce, 0x00, 0x00, 0xcf, 0xd0, 0xd1, 0xd2,
	0xd3, 0xac, 0xd4, 0xad, 0xd5, 0xae, 0xd6, 0xd7,
	0xd8, 0xd9, 0xda, 0xdb, 0x00, 0xdc, 0x00, 0x00,
	0xa6, 0xdd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const uint16_t kanatbl[] = {
	0x8140, 0x8142, 0x8175, 0x8176, 0x8141, 0x8145, 0x82f0, 0x829f,
	0x82a1, 0x82a3, 0x82a5, 0x82a7, 0x82e1, 0x82e3, 0x82e5, 0x82c1,
	0x815b, 0x82a0, 0x82a2, 0x82a4, 0x82a6, 0x82a8, 0x82a9, 0x82ab,
	0x82ad, 0x82af, 0x82b1, 0x82b3, 0x82b5, 0x82b7, 0x82b9, 0x82bb,
	0x82bd, 0x82bf, 0x82c2, 0x82c4, 0x82c6, 0x82c8, 0x82c9, 0x82ca,
	0x82cb, 0x82cc, 0x82cd, 0x82d0, 0x82d3, 0x82d6, 0x82d9, 0x82dc,
	0x82dd, 0x82de, 0x82df, 0x82e0, 0x82e2, 0x82e4, 0x82e6, 0x82e7,
	0x82e8, 0x82e9, 0x82ea, 0x82eb, 0x82ed, 0x82f1, 0x814a, 0x814b
};

// Unicode codepoints mapped from multiple SJIS codepoints.
static const uint16_t ambigious_unicodes[] = {
	0x2116,0x2121,0x2160,0x2161,0x2162,0x2163,0x2164,0x2165,
	0x2166,0x2167,0x2168,0x2169,0x2170,0x2171,0x2172,0x2173,
	0x2174,0x2175,0x2176,0x2177,0x2178,0x2179,0x221A,0x2220,
	0x2229,0x222A,0x222B,0x2235,0x2252,0x2261,0x22A5,0x2500,
	0x2501,0x2502,0x2503,0x250C,0x250F,0x2510,0x2513,0x2514,
	0x2517,0x2518,0x251B,0x251C,0x251D,0x2520,0x2523,0x2524,
	0x2525,0x2528,0x252B,0x252C,0x252F,0x2530,0x2533,0x2534,
	0x2537,0x2538,0x253B,0x253C,0x253F,0x2542,0x254B,0x3231,
	0x4E28,0x4EE1,0x4EFC,0x4F00,0x4F03,0x4F39,0x4F56,0x4F8A,
	0x4F92,0x4F94,0x4F9A,0x4FC9,0x4FCD,0x4FFF,0x501E,0x5022,
	0x5040,0x5042,0x5046,0x5070,0x5094,0x50D8,0x50F4,0x514A,
	0x5164,0x519D,0x51BE,0x51EC,0x5215,0x529C,0x52A6,0x52AF,
	0x52C0,0x52DB,0x5300,0x5307,0x5324,0x5372,0x5393,0x53B2,
	0x53DD,0x548A,0x549C,0x54A9,0x54FF,0x5586,0x5759,0x5765,
	0x57AC,0x57C7,0x57C8,0x589E,0x58B2,0x590B,0x5953,0x595B,
	0x595D,0x5963,0x59A4,0x59BA,0x5B56,0x5BC0,0x5BD8,0x5BEC,
	0x5C1E,0x5CA6,0x5CBA,0x5CF5,0x5D27,0x5D42,0x5D53,0x5D6D,
	0x5DB8,0x5DB9,0x5DD0,0x5F21,0x5F34,0x5F45,0x5F67,0x5FB7,
	0x5FDE,0x605D,0x6085,0x608A,0x60D5,0x60DE,0x60F2,0x6111,
	0x6120,0x6130,0x6137,0x6198,0x6213,0x62A6,0x63F5,0x6460,
	0x649D,0x64CE,0x654E,0x6600,0x6609,0x6615,0x661E,0x6624,
	0x662E,0x6631,0x663B,0x6657,0x6659,0x6665,0x6673,0x6699,
	0x66A0,0x66B2,0x66BF,0x66FA,0x66FB,0x670E,0x6766,0x67BB,
	0x67C0,0x6801,0x6844,0x6852,0x68C8,0x68CF,0x6968,0x6998,
	0x69E2,0x6A30,0x6A46,0x6A6B,0x6A73,0x6A7E,0x6AE2,0x6AE4,
	0x6BD6,0x6C3F,0x6C5C,0x6C6F,0x6C86,0x6CDA,0x6D04,0x6D6F,
	0x6D87,0x6D96,0x6DAC,0x6DCF,0x6DF2,0x6DF8,0x6DFC,0x6E27,
	0x6E39,0x6E3C,0x6E5C,0x6EBF,0x6F88,0x6FB5,0x6FF5,0x7005,
	0x7007,0x7028,0x7085,0x70AB,0x70BB,0x7104,0x710F,0x7146,
	0x7147,0x715C,0x71C1,0x71FE,0x72B1,0x72BE,0x7324,0x7377,
	0x73BD,0x73C9,0x73D2,0x73D6,0x73E3,0x73F5,0x7407,0x7426,
	0x7429,0x742A,0x742E,0x7462,0x7489,0x749F,0x7501,0x752F,
	0x756F,0x7682,0x769B,0x769C,0x769E,0x76A6,0x7746,0x7821,
	0x784E,0x7864,0x787A,0x7930,0x7994,0x799B,0x7AD1,0x7AE7,
	0x7AEB,0x7B9E,0x7D48,0x7D5C,0x7DA0,0x7DB7,0x7DD6,0x7E52,
	0x7E8A,0x7F47,0x7FA1,0x8301,0x8362,0x837F,0x83C7,0x83F6,
	0x8448,0x84B4,0x84DC,0x8553,0x8559,0x856B,0x85B0,0x8807,
	0x88F5,0x891C,0x8A12,0x8A37,0x8A79,0x8AA7,0x8ABE,0x8ADF,
	0x8AF6,0x8B53,0x8B7F,0x8CF0,0x8CF4,0x8D12,0x8D76,0x8ECF,
	0x9067,0x90DE,0x9115,0x9127,0x91D7,0x91DA,0x91DE,0x91E4,
	0x91E5,0x91ED,0x91EE,0x9206,0x920A,0x9210,0x9239,0x923A,
	0x923C,0x9240,0x924E,0x9251,0x9259,0x9267,0x9277,0x9278,
	0x9288,0x92A7,0x92D0,0x92D3,0x92D5,0x92D7,0x92D9,0x92E0,
	0x92E7,0x92F9,0x92FB,0x92FF,0x9302,0x931D,0x931E,0x9321,
	0x9325,0x9348,0x9357,0x9370,0x93A4,0x93C6,0x93DE,0x93F8,
	0x9431,0x9445,0x9448,0x9592,0x969D,0x96AF,0x9733,0x973B,
	0x9743,0x974D,0x974F,0x9751,0x9755,0x9857,0x9865,0x9927,
	0x999E,0x9A4E,0x9AD9,0x9ADC,0x9B72,0x9B75,0x9B8F,0x9BB1,
	0x9BBB,0x9C00,0x9D6B,0x9D70,0x9E19,0x9ED1,0xF929,0xF9DC,
	0xFA0E,0xFA0F,0xFA10,0xFA11,0xFA12,0xFA13,0xFA14,0xFA15,
	0xFA16,0xFA17,0xFA18,0xFA19,0xFA1A,0xFA1B,0xFA1C,0xFA1D,
	0xFA1E,0xFA1F,0xFA20,0xFA21,0xFA22,0xFA23,0xFA24,0xFA25,
	0xFA26,0xFA27,0xFA28,0xFA29,0xFA2A,0xFA2B,0xFA2C,0xFA2D,
	0xFF02,0xFF07,0xFFE2,0xFFE4,
};

static int uint16_compare(const void *a, const void *b) {
	return *(const uint16_t *)a - *(const uint16_t *)b;
}

#if 0
void generate_ambigious_unicodes_table(void) {
	uint8_t *cnt = calloc(0x10000, sizeof(uint16_t));
	uint16_t *amb = calloc(0x10000, sizeof(uint16_t));
	int nr_amb = 0;
	for (int b1 = 0x81; b1 <= 0xfc; b1++) {
		if (b1 >= 0xa0 && b1 <= 0xdf)
			continue;
		for (int b2 = 0x40; b2 <= 0xfc; b2++) {
			uint16_t u = s2u[b1 - 0x80][b2 - 0x40];
			if (!u)
				continue;
			if (++cnt[u] == 2)
				amb[nr_amb++] = u;
		}
	}
	qsort(amb, nr_amb, sizeof(uint16_t), uint16_compare);
	printf("static const uint16_t ambigious_unicodes[] = {");
	for (int i = 0; i < nr_amb; i++) {
		if (i % 8 == 0)
			printf("\n\t");
		printf("0x%04X,", amb[i]);
	}
	printf("\n};\n");
}
#endif

bool is_unicode_safe(uint8_t c1, uint8_t c2) {
	if (!is_sjis_byte1(c1) || !is_sjis_byte2(c2))
		return false;
	int cp = s2u[c1 - 0x80][c2 - 0x40];
	if (!cp)
		return false;
	if ((cp & 0xf000) == 0xe000)
		return false;  // Gaijis should be escaped
	const int nelem = sizeof(ambigious_unicodes) / sizeof(uint16_t);
	return !bsearch(&cp, ambigious_unicodes, nelem, sizeof(uint16_t), uint16_compare);
}

static int unicode_to_sjis(int u) {
	if (u < 128)
		return u;
	if (u > 0xffff)
		return 0;

	static uint16_t *u2s = NULL;
	if (!u2s) {
		// Create a reverse lookup table from s2u.
		u2s = calloc(0x10000, sizeof(uint16_t));
		for (int b1 = 0x81; b1 <= 0xfc; b1++) {
			if (b1 >= 0xa0 && b1 <= 0xdf)
				continue;
			for (int b2 = 0x40; b2 <= 0xfc; b2++) {
				uint16_t u = s2u[b1 - 0x80][b2 - 0x40];
				if (u && !u2s[u])
					u2s[u] = b1 << 8 | b2;
			}
		}
	}
	return u2s[u];
}

bool is_valid_sjis(uint8_t c1, uint8_t c2) {
	return is_sjis_byte1(c1) && is_sjis_byte2(c2) && s2u[c1 - 0x80][c2 - 0x40];
}

char *sjis2utf_sub(const char *str, int substitution_char) {
	const uint8_t *src = (uint8_t *)str;
	uint8_t *dst = malloc(strlen(str) * 3 + 1);
	uint8_t *dstp = dst;

	while (*src) {
		if (*src <= 0x7f) {
			*dstp++ = *src++;
			continue;
		}

		int c;
		if (*src >= 0xa0 && *src <= 0xdf) {
			c = 0xff60 + *src - 0xa0;
			src++;
		} else if (is_valid_sjis(src[0], src[1])) {
			c = s2u[src[0] - 0x80][src[1] - 0x40];
			src += 2;
		} else {
			if (substitution_char < 0)
				error("Invalid SJIS byte sequence %02x %02x", src[0], src[1]);
			c = substitution_char;
			src++;
		}

		if (c <= 0x7f) {
			*dstp++ = c;
		} else if (c <= 0x7ff) {
			*dstp++ = 0xc0 | c >> 6;
			*dstp++ = 0x80 | (c & 0x3f);
		} else {
			*dstp++ = 0xe0 | c >> 12;
			*dstp++ = 0x80 | (c >> 6 & 0x3f);
			*dstp++ = 0x80 | (c & 0x3f);
		}
	}
	*dstp = '\0';
	return (char *)dst;
}

char *utf2sjis_sub(const char *str, int substitution_char) {
	const uint8_t *src = (uint8_t *)str;
	uint8_t *dst = malloc(strlen(str) + 1);
	uint8_t *dstp = dst;

	while (*src) {
		if (*src <= 0x7f) {
			*dstp++ = *src++;
			continue;
		}

		int u;
		if (*src <= 0xdf) {
			u = (src[0] & 0x1f) << 6 | (src[1] & 0x3f);
			src += 2;
		} else if (*src <= 0xef) {
			u = (src[0] & 0xf) << 12 | (src[1] & 0x3f) << 6 | (src[2] & 0x3f);
			src += 3;
		} else {
			if (substitution_char < 0)
				error("Unsupported UTF-8 sequence");
			*dstp++ = substitution_char;
			do src++; while ((*src & 0xc0) == 0x80);
			continue;
		}

		if (u > 0xff60 && u <= 0xff9f) {
			*dstp++ = u - 0xff60 + 0xa0;
		} else {
			int c = unicode_to_sjis(u);
			if (c) {
				*dstp++ = c >> 8;
				*dstp++ = c & 0xff;
			} else {
				if (substitution_char < 0)
					error("Codepoint U+%04X cannot be converted to Shift_JIS", u);
				*dstp++ = substitution_char;
			}
		}
	}
	*dstp = '\0';
	return (char*)dst;
}

const char *validate_utf8(const char *s) {
	while (*s) {
		if ((uint8_t)*s <= 0x7f) {
			s++;
		} else if ((uint8_t)*s <= 0xbf) {
			return s;
		} else if ((uint8_t)*s <= 0xdf) {
			if (!UTF8_TRAIL_BYTE(s[1]))
				return s;
			s += 2;
		} else if ((uint8_t)*s <= 0xef) {
			if (!UTF8_TRAIL_BYTE(s[1]) || !UTF8_TRAIL_BYTE(s[2]))
				return s;
			s += 3;
		} else if ((uint8_t)*s <= 0xf4) {
			if (!UTF8_TRAIL_BYTE(s[1]) || !UTF8_TRAIL_BYTE(s[2]) || !UTF8_TRAIL_BYTE(s[3]))
				return s;
			s += 4;
		} else {
			return s;
		}
	}
	return NULL;
}

uint8_t compact_sjis(uint8_t c1, uint8_t c2) {
	return c1 == 0x81 ? hankaku81[c2 - 0x40] :
		   c1 == 0x82 ? hankaku82[c2 - 0x40] : 0;
}

uint16_t expand_sjis(uint8_t c) {
	if (!is_compacted_sjis(c))
		return 0;
	if (c == ' ')
		return 0x8140; // full-width space
	return kanatbl[c - 0xa0];
}

// 1-byte encoding used in the scenario files of Gakuen Senki and
// Little Vampire (MSX2). Note that \0 is a valid character here.
static const char16_t msx_msg_table[256] =
	// 0x00 - 0x1F
	u"　！＂＃＄％＆＇（）＊＋，－．／０１２３４５６７８９［］＜＝＞？"
	// 0x20 - 0x3F (ACT commands)
	u"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
	// 0x40 - 0x5F (ACT commands)
	u"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
	// 0x60 - 0x7F
	u"＠ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺ\0＼\0＾\0"
	// 0x80 - 0x9F
	u"\0\0\0\0\0\0をぁぃぅぇぉゃゅょっ\0あいうえおかきくけこさしすせそ"
	// 0xA0 - 0xBF
	u"\0。「」、・ヲァィゥェォャュョッーアイウエオカキクケコサシスセソ"
	// 0xC0 - 0xDF
	u"タチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワン゛゜"
	// 0xE0 - 0xFF
	u"たちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわん\0\0";

// A different 1-byte encoding used in the verbs / objects listing of
// Gakuen Senki and Little Vampire (MSX2). JIS X 0201 + hiragana.
static const char16_t msx_ag00_table[256] =
	// 0x00 - 0x1F
	u"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
	// 0x20 - 0x3F
	u"　！＂＃＄％＆＇（）＊＋，－．／０１２３４５６７８９：；＜＝＞？"
	// 0x40 - 0x5F
	u"＠ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺ［＼］＾＿"
	// 0x60 - 0x7F
	u"｀ａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚ｛｜｝～\0"
	// 0x80 - 0x9F
	u"\0\0\0\0\0\0をぁぃぅぇぉゃゅょっ\0あいうえおかきくけこさしすせそ"
	// 0xA0 - 0xBF
	u"\0。「」、・ヲァィゥェォャュョッーアイウエオカキクケコサシスセソ"
	// 0xC0 - 0xDF
	u"タチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワン゛゜"
	// 0xE0 - 0xFF
	u"たちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわん\0\0";

#define JIS_DAKUTEN 0xDE
#define JIS_HANDAKUTEN 0xDF

static char16_t combine_msx(char16_t base, uint8_t mark) {
	if (mark == JIS_DAKUTEN) {
		if (base == u'う') return u'ゔ';
		if (base >= u'か' && base <= u'ち' && (base % 2 != 0)) return base + 1;
		if (base >= u'つ' && base <= u'と' && (base % 2 == 0)) return base + 1;
		if (base >= u'は' && base <= u'ほ' && (base - u'は') % 3 == 0) return base + 1;
		if (base == u'ウ') return u'ヴ';
		if (base >= u'カ' && base <= u'チ' && (base % 2 != 0)) return base + 1;
		if (base >= u'ツ' && base <= u'ト' && (base % 2 == 0)) return base + 1;
		if (base >= u'ハ' && base <= u'ホ' && (base - u'ハ') % 3 == 0) return base + 1;
	} else if (mark == JIS_HANDAKUTEN) {
		if (base >= u'は' && base <= u'ほ' && (base - u'は') % 3 == 0) return base + 2;
		if (base >= u'ハ' && base <= u'ホ' && (base - u'ハ') % 3 == 0) return base + 2;
	}
	return 0;
}

static char *msx2sjis(const uint8_t *src, int len, const char16_t table[256]) {
	uint8_t *dst = malloc(len * 2 + 1);
	uint8_t *dstp = dst;
	const uint8_t *end = src + len;
	char16_t last_c = 0;

	while (src < end) {
		uint8_t b = *src++;
		char16_t c = table[b];
		if (c == 0)
			error("Invalid MSX byte %02x", b);

		if (last_c && (b == JIS_DAKUTEN || b == JIS_HANDAKUTEN)) {
			char16_t combined = combine_msx(last_c, b);
			if (combined) {
				dstp -= 2;
				c = combined;
			}
		}
		last_c = c;

		c = unicode_to_sjis(c);
		if (c <= 0xff) {
			*dstp++ = (uint8_t)c;
		} else {
			*dstp++ = (uint8_t)(c >> 8);
			*dstp++ = (uint8_t)(c & 0xff);
		}
	}
	*dstp = '\0';
	return (char *)dst;
}

char *msx2sjis_msg(const char *str, int len) {
	return msx2sjis((const uint8_t*)str, len, msx_msg_table);
}

char *msx2sjis_data(const char *str) {
	return msx2sjis((const uint8_t*)str, strlen(str), msx_ag00_table);
}

static int unicode_to_msx(uint16_t u, const char16_t table[256]) {
	for (int i = 0; i < 256; i++) {
		if (table[i] == u)
			return i;
	}
	return -1;
}

static char *utf2msx(const char *str, const char16_t table[256], int *out_len) {
	const uint8_t *src = (uint8_t *)str;
	uint8_t *dst = malloc(strlen(str) + 1);
	uint8_t *dstp = dst;

	while (*src) {
		int u;
		if (*src <= 0x7f) {
			u = *src++;
		} else if (*src <= 0xdf) {
			u = (src[0] & 0x1f) << 6 | (src[1] & 0x3f);
			src += 2;
		} else if (*src <= 0xef) {
			u = (src[0] & 0xf) << 12 | (src[1] & 0x3f) << 6 | (src[2] & 0x3f);
			src += 3;
		} else {
			error("Unsupported UTF-8 sequence");
		}

		// Try splitting
		uint16_t base = 0;
		uint8_t mark = 0;
		if (u == u'ゔ') { base = u'う'; mark = JIS_DAKUTEN; }
		else if (u >= u'が' && u <= u'ぢ' && (u % 2 == 0)) { base = u - 1; mark = JIS_DAKUTEN; }
		else if (u >= u'づ' && u <= u'ど' && (u % 2 != 0)) { base = u - 1; mark = JIS_DAKUTEN; }
		else if (u >= u'ば' && u <= u'ぽ' && (u - u'は') % 3 == 1) { base = u - 1; mark = JIS_DAKUTEN; }
		else if (u >= u'ば' && u <= u'ぽ' && (u - u'は') % 3 == 2) { base = u - 2; mark = JIS_HANDAKUTEN; }
		else if (u == u'ヴ') { base = u'ウ'; mark = JIS_DAKUTEN; }
		else if (u >= u'ガ' && u <= u'ヂ' && (u % 2 == 0)) { base = u - 1; mark = JIS_DAKUTEN; }
		else if (u >= u'ヅ' && u <= u'ド' && (u % 2 != 0)) { base = u - 1; mark = JIS_DAKUTEN; }
		else if (u >= u'バ' && u <= u'ポ' && (u - u'ハ') % 3 == 1) { base = u - 1; mark = JIS_DAKUTEN; }
		else if (u >= u'バ' && u <= u'ポ' && (u - u'ハ') % 3 == 2) { base = u - 2; mark = JIS_HANDAKUTEN; }

		if (base) {
			int b_base = unicode_to_msx(base, table);
			if (b_base != -1) {
				*dstp++ = (uint8_t)b_base;
				*dstp++ = mark;
				continue;
			}
		} else {
			int b = unicode_to_msx(u, table);
			if (b != -1) {
				*dstp++ = (uint8_t)b;
				continue;
			}
		}
		error("Codepoint U+%04X cannot be converted to MSX", u);
	}
	*dstp = '\0';
	if (out_len)
		*out_len = dstp - dst;
	return (char *)dst;
}

char *utf2msx_msg(const char *str, int *out_len) {
	return utf2msx(str, msx_msg_table, out_len);
}

char *utf2msx_data(const char *str) {
	return utf2msx(str, msx_ag00_table, NULL);
}

bool is_msx_message_char(uint8_t c) {
	return msx_msg_table[c] != 0;
}
